require 'socket'

#
# L&S Light Control
#
class Light
  def on
    send_messages MESSAGES_ON
  end

  def off
    send_messages MESSAGES_OFF
  end

protected

  def send_messages(messages)
    s = UDPSocket.new
    s.setsockopt Socket::SOL_SOCKET, Socket::SO_BROADCAST, true

    messages.each do |data|
      s.send data.pack('C*'), 0, '<broadcast>', 32_001
    end
    s.close
  end

  MESSAGES_ON = [
    [
      0x50, 0x5b, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,
      0x5a, 0x5a, 0x5a, 0x5a, 0x58, 0x5a, 0xe8, 0x5a,
      0x1a
    ],
    [
      0x50, 0x5b, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,
      0x5a, 0x5a, 0x5a, 0x5a, 0x58, 0x5a, 0xa8, 0x5a,
      0x5a
    ]
  ].freeze

  MESSAGES_OFF = [
    [
      0x50, 0x5b, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,
      0x5a, 0x5a, 0x5a, 0x5a, 0x58, 0x5a, 0x28, 0x5a,
      0xda
    ],
    [
      0x50, 0x5b, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,
      0x5a, 0x5a, 0x5a, 0x5a, 0x58, 0x5a, 0xa8, 0x5a,
      0x5a
    ]
  ].freeze
end

case ARGV[0]
when 'on'
  Light.new.on
when 'off'
  Light.new.off
end
